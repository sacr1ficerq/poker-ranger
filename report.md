# Отчет о курсовой работе

## Оглавление (TODO)

1. **Оглавление**  
2. **Аннотация**  
   - **Название проекта**  
   - **Цель проекта**  
   - **Основные задачи**  
   - **Планируемые результаты**  
   - **Новизна проекта**  
   - **Целевая аудитория**  
   - **Ключевые слова**
3. **Введение**  
4. **Основная часть**  
    - **Глава 1. Описание предметной области и задачи.**
    - **Глава 2. Архитектура и технологии**
    - **Глава 3. Реализация алгоритмов анализа стратегий**
    - **Глава 4. Разработка интерфейса**
    - **Глава 5. Тестирование и результаты**
    - **Заключение**
5. **Обзор литературы ???**
6. **Список литературы ???**  
7. **Терминологический словарь**  

## Аннотация

**Название проекта:** Разработка веб-приложения для анализа и оптимизации игровых стратегий в Heads-up Техасском Холдеме

**Цель проекта:** Создание веб-приложения, которое позволит игрокам практиковать свои стратегии 
в игре Heads-up Техасский Холдем в контролируемой среде. 
Приложение будет использовать семплинг рук из фиксированных начальных диапазонов и
матожидание в конечных вершинах игрового дерева для
снижения дисперсии и ускорения сходимости к реальному винрейту.

**Основные задачи:**

1. Разработка графического интерфейса для игры в Техасский Холдем.
2. Создание функционала для выбора префлоп диапазона и начального пота.
3. Разработка системы для семплирования рук и расчета винрейтов.
4. Тестирование и сравнение с существующими решениями.

**Планируемые результаты:**

- Веб-приложение с интуитивно понятным интерфейсом для игровой практики фиксированных стратегий в техасском холедеме.
- Возможность точечной тренировки в изолированной игровой среде.

**Новизна проекта:**

- Новый подход к тренировке в зафиксированных игровых условиях.
- Возможность точечной тренировки определенных типов ситуаций (текстура флопа и префлоп экшн).
- Отсечение boilarplate части техасского холдема, на которую расходуется значительная часть времени и сил, при отсутсвии в них реальной возможности отколнится от базовой стратегии.

**Целевая аудитория:**

- Профессиональные игроки в покер, стремящиеся отточить свои стратегии в конкретных игровых ситуациях.
- Любители, заинтересованные в тренировке практических покерных навыков в контролируемой среде.

**Ключевые слова:** Веб-приложение, Heads-up Техасский Холдем, оптимизация стратегий, игровые алгоритмы.

## Введение

Техасский Холдем, является одной из самых популярных и сложных стратегических игр, требующей от игроков не только удачи, но и глубокого понимания общей игровой стратегии и знания паттернов поведения других игроков. В последние годы интерес к оптимизации собственных игровых стратегий значительно вырос из-за увеличения числа профессиональных игроков в онлайне и снижения винрейтов из-за общего усиления поля и повышения рейка. Однако, несмотря на наличие множества инструментов для изучения покерных стратегий, большинство из них либо слишком сложны для начинающих, либо не предоставляют достаточной гибкости для практики конкретных покерных сценариев. Кроме игры непосредственно в покер и GTO тренажеров, на текущий момент нет возможности 'пощупать' на практике определенный стратегический паттерн или отточить какой-то спот против партнера.

Целью данной работы является разработка веб-приложения, которое позволит игрокам именно эту роскошь, ради которой профессиональный игроки отыгрывают тысячи рук - пощупать стратегии в определенных спотах, получить интуитивное понимание механики покера и конкретные решения в часто встречающихся ситуациях.

Актуальность проекта обусловлена растущим интересом к покеру как к интеллектуальной игре, требующей стратегического мышления. Многие игроки, особенно начинающие, сталкиваются с трудностями при попытке проанализировать свою стратегию в определенном споте. Предлагаемое приложение позволит не только упростить этот процесс, но и сделать его более доступным для широкой аудитории, включая как профессионалов, так и любителей.

Основные задачи проекта включают разработку графического интерфейса, создание функционала для выбора дерева решений, начальных диапазонов и текстуры флопа, а также реализацию системы для семплирования рук и расчета винрейтов. Планируемые результаты включают веб-приложение с интуитивно понятным интерфейсом, которое позволит игрокам анализировать и оптимизировать свои стратегии, а также тренироваться в контролируемой среде.

Структура работы следующая: в первой главе будет дано описание предметной области и задачи, во второй главе рассмотрены архитектура и технологии, используемые в проекте, в третьей главе описана реализация алгоритмов семплирования и подсчета винрейта, в четвертой главе представлена разработка интерфейса, а в пятой главе приведены результаты тестирования и сравнение с существующими решениями. В заключении будут подведены итоги работы и намечены перспективы дальнейшего развития проекта.

Таким образом, данная работа представляет собой важный шаг в направлении создания инструментов для анализа и оптимизации покерных стратегий, которые будут полезны как для профессиональных игроков, так и для любителей, стремящихся улучшить свои навыки игры в покер. Лично для меня, как для профессионального игрока в покер, это будет резкий скачок в продуктивности изучения тонких игровых решений, а также в скорости, с которой я могу оттачивать наработанные идеи и искать лики впоследствии.

## Основная часть

### **Глава 1. Описание предметной области и задачи**

Покер это игра, где дистанция между действием и наградой за него довольно большая. Это позволяет игрокам играть без понимания настоящий винрейтов их действий и проигрывать на длинной дистанции огромные деньги. Я перешел в покер из шахмат, и был удивлен насколько некоторые игроки мало понимают механики покера и насколько большие даже для них самих деньги они при этом в него проигрывают. В шахматах гораздо проще дать оценку текущей позиции во время игры, выделить ошибки в сыгранных ходах, придти к правильным выводам и подвинуть свою игру в оптимальную сторону. Это позволяет игрокам довольно точно оценить свои шансы в игре с определенным соперником. Никакой новичек не сядет играть с гроссмейтером на большую для него сумму денег, но в покере это происходит постоянно. С появлением неполоной информации оценка матожидания определенных действий сильно размывается.

Обычный покер можно рассмотреть как стохастическую оценку надлежащей игры с полной информацией. Пример такой игры: покер раскладывается в континуальное дерево вариантов, где внутри каждой вершины игроки фиксируют свою стратегию. В результате у каждого игрока получается универсальный алгоритм игры. Столкновение алгоритмов имеет однозначно определенное матожидание, которое в точности равно матожиданию применения этих алгоритмов в обычном покере.

Конечно в такую игру не получилось бы сыграть. Но идея, что покер - ее стохастическая оценка, очень важна в контексте рассуждения про его теоритическое вопроятие. Этот стохастический процесс превносит огромную дисперсию и сильно зашумляет настоящие винрейты игроков.

Около двадцати лет появились первые солверы. Они итеративно ищут эквилибриум в подпространстве надлежащей игры с фиксированными сайзингами, в которой дерево решений кончено. Эта инъекция классического покера в конечную игру с полной информацией перевернула понимание покера и дала новый подход к изучению покерной стратегии. В современном мире большинство покерных профессионалов играют в покер не меньше, чем работают с солверами и изучают эквиоибриумы в подпространствах порожденных инъекцией классического покера в конечное дерево вариантов, так как человеческий мозг не приспособлен обучаться end-to-end на игре в классический покер.

Моя цель в этой курсовой работе - сделать первый шаг к созданию другой интерпретации покера как игры с полной информацией. В этой новой игре люди могут эффективно тренировать свои покерные навыки и улучшать понимание покерных механик и устройства покера с точки зрения теории игр. Попытка минимизировать шум и расстояние между действиями и реализацией их "награды".

#### Задачи проекта

Все сильные игроки в покер с точностью до 5% знают любой диапазон, который они будут играть на префлопе
в любой ветке дерева префлоп решений. Большинство профессиональных игроков отыграло десятки тысяч
раздач в онлайне за 6-макс столом и все префлоп действия в раздаче против другого сильного игрока делаются
автоматически.

Также большинство профессионалов имеют спаринг партнера, с которым они делятся новыми наработками
и тренируются. Тренироваться со спаринг партнером максимально эффективно на текущий момент можно только в 
формате heads-up. Однако несмотря на то, что это самый сложный вид покера и он требует максимальной концентрации, 
он не помогает напрямую в игре с бОльшим количеством игроков. При этом практически во всех реальных играх 
учавствует больше 6 человек, и надо отдельно готовиться и изучать диапазоны, в которых стратегия постфлоп
и префлоп отличается разительно от игры в heads-up. Мое приложение - самый эффективный способ отработки
любых прелоп диапазонов и ситуаций в контролируемой среде со своим спаринг партнером. 
Допустим вы готовитесь к переходу к игре в 9-макс столах, при этом до этого оба играли только 6-макс.
Оптимальные диапазоны для игры в 9-макс столах есть в открытом доступе, однако просто их запонимить будет 
недостаточно для эффективной реализации стратегий в этих диапазонах в боевых условиях.
Мое приложение позволит вам зафиксировать играемые диапазоны с разных позиций и ситуацию например:
- BBvsBTN 3bp. 3bet pot большой блайнд против баттона. 
- UTG+1vsBB SRP. Single raise pot вторая позиция против большого блайнда. Уникальный спот, которого нет в игре за короким столом.
В моем приложении можно зафиксировать диапазоны и проанализировать с любой точностью в игровом формате любой спот, 
почувствовать как он играется в раздаче против другого сильного оппонента сколько угодно раз в любой выбранной глубине.

### **Глава 2. Архитектура и технологии**  

До этого проекта я не написал в жизни ни единой строчки на JS и не имел абсолютно никакого опыта разработки веб приложений. Было очень страшно брать большой проект в области, где у меня нет абсолютно никакой экспертизы, но я очень рад, что все таки решился на это.

Я прошел через три этапа технилогий, которые я исользовал на этом проекте.

#### Vue.js. + node_poker

 Я начал с исследования вохможных вариантов фронтэнда и остановился на `Vue.js` - относительно простой фреймворк с системой шаблонов и большим количеством синтаксического сахара. Этот вариант показался мне наиболее приемлемым с точки зрения порога входа и простоты синтаксиса. В качестве бэекенда изначальный план был использовать Next.js и переписать под свои задачи библиотеку для моделирования игры в покер `node_poker`. Однако когда я начал писать приложение, оказалось, что без знания JS и опыта пользования фронтэнд фреймворками быстро двигаться с `Vue` и отлаживать возникающие проблемы потрясающе энергозатрано, а также такой способ разработки мне очень тяжело дается, так как я не понимаю внутреннего устройства инструмента, с которым работаю. Помимо этого при пристальном взгляде внутрь библиотеки я обнаружил код такого формата:

![node-poker](data/node-poker.jpg)

Для меня это было неприемлемой опцией, так как мне нужно было быстро переписывать библиотеку под нужные мне задачи, а также чтобы вычисление выигрывающей руки работало довольно быстро, так как в дальнейшем я планировал добавить подсчет эквити диапазон против диапазона. Поэтому я полностью отказался от этой опции и начал разработку с полного нуля.

#### Radical simplicity

Чтобы лучше понять блоки, на которых строится мое приложение и индивидуальное взаимодействие компонент, я решил построить свое приложение по кирпичу на голом JS без фреймворков и излишеств.

Долгое время у меня даже не было автоматической сборки и пакетного менеджера. Я намеренно отказался в начале от `Node.js`, `Vite` и других вспомогательных инструментов. И даже LSP (language-server-protocall, **TODO**). Голый neovim и открытый в соседнем окне браузер, единственные зависимости во всем проекте - tailwind.css и socket.io через CDN/. Такой выбор был продиктован моим желанием развивать проект после окончания написания курсовой работы по его основе. Я уже несколько лет думал про то, что я хотел бы сделать в этом направлении и я не представляю реализацию проекта такого масштаба без понимания того, как устроенны внутри блоки на которых строятся основы.

Также к основе из JS я написал первую версию моей библиотеки для моделирования покерных взаимодействий между игроками на Python. При всей моей нелюбви к Python, этот язык позволяет мне двигаться максимально быстро и тратить минимум времени на рефакторинг, которого пришлось проводить довольно много в дальнейшем. Также я написал простенький сервер на `Flask` - *очень приятная библиотека для программирования энд-поинтов, выбором которой я был очень доволен.* **TODO**

После того как я закончил минимально работающую версию базового покера, я оценил структуру кода и скорость, с которой я могу дальше двигаться с vanilla JS и понял, что на большой дистанции, это не валидный вариант, и что мне все таки нужен фронэтнд фреймворк. У меня уже были минимальные знания о принципах работы JS и минимальные навыки владения синтаксисом, поэтому мне показалось, что переход на правильный фреймоворк не затормозит мое освоение основ веб программирования, а только ускорит добавление нового функционала.

#### Балланс минимализма и эргономичности

Я выбирал из трех вариантов: вернуться к `Vue`, или изучить какой-то из легковестных современных фреймворков - `Svelte` или `mithril`. `Mithril` и `Svelte` расположены довольно близко к ванильному `JS` и превносят минимальный уровень абстракции в код, что для меня показалось очень привлекательным. Я остановил свой выбор на `Mithril` после того, как узнал, что `lichess.org` в какой-то момент мигрировал на этот язык. При огромном масщтабе этого продукта, он поддерживается одним человеком, который в большей степени бэкенд разработчик. При этом мне показалось, что на этот фреймвор будет легче переписать мой JQery-style код, вместо написания фронтэнда с полного нуля. Но из-за отсутсвия понимая механик фреймворка пришлось все таки переписывать обе части - Lobby и Room с чистого листа, дублируя внешний вид существующей версии.

### **Глава 3. Backend library**

В этой главе будет описана реализация алгоритмов для анализа стратегий, включая семплирование рук и расчет винрейтов.  

#### Часть 1. Реализация классического покера

В последующий двух главах я распишу свой путь от пустого проекта до финального результата.

Хотелось бы подчеркнуть, что этот курсовой проект для меня несет больше образовательную
ценность, чем какую-либо другую, так как несмотря на то, что проект в общем является для
меня большой целью, которую я давно хотел воплотить, у меня нет достаточных навыков,
чтобы создать продукт достаточного качества. Поэтому я буду делать акцент в этом отчете именно на
своей образовательной траектории и как я шел к финальному продукту, а не на архитектурных деталях получившегося
приложения.

Изначально, как я уже отметил во втрой главе, я планировал использовать Vue и уже готовую библиотеку
для моделирования игры в покер. Однако увидев содержание библиотеки, я понял, что 
не смогу дописывать в нее нужный мне функционал, а также мне комфортнее будет двигаться на Python самому.
Поэтому я решил начать с чистого листа и находу разобраться с архитектурой и механикой
работы движка для моделирования покера.

Как я понял, разные программисты любят начинать с разных концов проекта - кто-то с написания основ 
бэкенд библиотки, кто-то с набрасывания фундамента фронтэнда, под который потом пишется бэекенд.
Мне гораздо проще было начать писать бэкенд с нуля, так как я очень отдаленно представлял себе
как будет выглядет фронтэнд и я предполагал, что создание бекэнд архитектуры будет неплохим стартом, который 
даст мне фундамент, на котором я смогу выстраивать логику приложения.

С начала проекта я решил фиксировать важные продвижения через систему контроля версий.
Как раз чтобы по ним было в конце проще писать отчет. Надеюсь, это поможет мне не упустить
важных деталей разработки и позволит лучше отобразить мою траекторию. 

Все мои коммиты и стадии разработки можно найти в моем репозитории на github.com.

Первые шаги в сторону реализации бозового покера были сделаны довольно в быстром темпе.
Я начал с того, что создал три класса - Table, Player, Round. В них я хотел инкапсулиовать
логику соответствующий объектов. 
- Table отвечает за то, какие игроки сидят за столом, взаимодействие с ними, а также
посадку/высадку игроков, также поддерживается проеужточная информация формата: у кого сейчас кнопка
диллера. Также через этого класс идет взаимодействие фронтенда с бекендом, хотя на тот момент не до конца
было понятно как именно это будет реализованно.
```python
class Table:
    def __init__(self, sb, bb):
        self.bb = bb
        self.sb = sb
        self.players = []
        self.button = 0  # button index

        self.current_round = None
```
- Round отвечает за хранение динамической информации типа размер пота, чье сейчас слово, внутриигровые действия,
переход с между улицами, постановка блайндов. Примерно так выгляделели поля внутри класса.
```python
class Round:
    def __init__(self, players, table):
        # players in game (including all_in) sorted by left to act
        first = table.button + 1

        self.players = players[first:] + players[:first]
        assert len(players) >= 2, 'not enough players'
        self.table = table

        self.sb = table.sb
        self.bb = table.bb

        self.street = 'preflop'
        self.deck = Deck()
        self.pot = 0
        self.max_bet = 0
        self.board = []
```
- Player отвечает за класс игрока. Простым решением, о котором я жалею, было инкапсулировать игровые действия
внутри класса игрока, что приводит к цикличной ссылке на родительский класс и проверку состояний через обращение к
этому классу. Общее назначение класса было хранить информацию про игрока, а именно: его стек, сколько он поставил в 
этом раунде, какие у него в руке карты, а также флаги: в олине игрок, сыграл ли он уже в этот круг и его ли сейчас очередь играть.
В основном все эти решения выступали как костыли для сиюминутного решения проблем, и потом часть из них, например состояние было
переделано по-другому, но на тот момент это казалось интутивным решением. 
```python
class Player:
    def __init__(self, name, stack, table):
        self.name = name
        self.stack = stack
        self.table = table

        self.sit_out = False

        self.folded = False
        self.all_in = False
        self.acted = False
        self.is_acting = False

        self.chips_bet = 0

        self.cards = []
```
Также я добавил класс Deck, который я планировал сильно расширить при добавлении функционала,
связанного с семплингом рук из диапазона и другие взаимодействия с вероятностным подходом
к семплигну карт. На тот момент его функцией было просто хранение живых карт, а также перемешивание
при создании нового экземпляра.

``` python
class Deck:
    def __init__(self):
        self.deck = []
        self.fill()
        self.shuffle()
```

Это уже могло работать и можно было отыгрывать префлоп, но не было поддержки шоудауна, а также проблемы
с олинами и некоторые баги связанные с неправильным определение позиции игрока на определенной улице.
Мне понравилось мое решение в начале раунда фиксировать порядок игроков за столом на постфлопе, а не
вычислять его каждый раз заново. В тот момент я слабо понимал в какую сторону будет расти приложение, поэтому
я писал покер для общего случая с любым количеством игроков, что я изменил в процессе разработке далее.

Большой проблемой было тестирование. В Python я не работал с тестами, а писал до этого только большие классы для
тестирования на C++ с помощью Google Test. В этом проекте я тестировал все при помощи файла example.py, что
было не очень удобно и на это уходило много времени. В последующий версиях мне удалось это исправить.

После написания нетривиальной функции для определения победителя на шоудауне, я решил, что стоит приступить к 
написанию базового фронтэнда. Эту функцию (оценки выигрывающей руки) я написал при помощи генеративной нейросети, 
так как обработать все edge кейсы было довольно затруднительно, особенно в отсутсвии хорошего пайплайна с тестированием.

После написания базового фронтенда обнаружилось множество багов. Чтобы тестировать работоспособность библиотеки
непобходимо было разработать систему для тестирования различных частей программы. Для этого я выбрал pytest - как я понял
довольно популярное решение для написания юнит тестов. В первых версиях тестирования код был неорганизован и по сути
тестировал только класс Round, а остальные классы цеплял только через зависимость поведения Round от них. 
Для улучшения процесса разработки и тестирования, а также для лучшей коммуникации между фронтэндом и бэкендом я провел
небольшой рефакторинг, который был вызван идеей переделать архитектуру во фронтэнде. Теперь класс Player не хранил
все состояния через флаги, а хранил поле типа PlayerState, которое однозначно определяло в каком состоянии находится игрок:

```python
class PlayerState(Enum):
    BASE = ''
    FOLDED = 'folded'
    ALLIN = 'all-in'
    ACTING = 'acting'
    WINNING = 'winning'
    LOOSING = 'loosing'
    SITOUT = 'sit-out'
```

Вместе с ним был добавлен другой enum класс Action, хранящий игровые действия игрока. Во все классы для коммуникации с 
фронтэндом был добавлен метод state(), который сам сериализовывал нужные для отображения
поля и отдавал для последующей сериализации в JSON словарь из примитивных типов. Также для скрытия карт игрока от других,
был добавлен метод private_state, который вызывался сервером для персонального обновления
состояний. В процессе рефакторинга я переписал ключевые методы полностью под heads-up версию покера, так как решил,
что мое приложение в обозримом будущем будет поддерживать только эту версию.

Во время написания тестов и рефакторинга фронтенда, я заметил очень неприятную особенность JS. Возможно это продиктованно
моим отсутствием опыта с языком, но у меня часто вознокали проблемы с десериализацией состояний на стороне клиента, а также с 
десериализацией информации про запрос со стороны сервера. Это наталкнуло меня на использование очень приятного инструмента - dataclasses.
В dataclasses есть метод todict, который позволяет очень удобно конвертировать состояния в промежуточный формат, который легко сериализуется
в JSON. Я разработал новую систему состояний для каждого объекта, про который нужна была информация на стороне клиента:
- TableData
- PlayerData
- RoundData

Теперь у меня был отдельный красивый файл states.py, в который я мог обращаться при уточнении, какого типа то или иное поле в отправленном
состоянии, а также LSP подсказывал мне, когда я конвертировал в неправильный формат при работе с библиотекой или при добавлении новых
эндпоинтов на сервере. С этим упрощением работы процесс тестирования тоже сильно упростился. А также я переоткрыл для себя Python 
в новом виде. Я пробежался по всему коду и проставил тайпинги, и получилось поймать несколько багов, а также ускорить написание нового кода.
Стыдно признаться, что я не использовал эту возможность до этого. В больших функциях с неясным return value я проставлял тайпинги, но
точно в том масштабе, в который я превратил новую версию моей codebase. 

После этих улучшений я легко дописал функционал для обработки олинов, а также тестирования многих других граничных случаев. К примеру
самой большой проблемой оказался стык суперкоротких стеков и автоматической постановки блайндов. Для устранения багов в этой области я
написал небольшой, но очень некрасивый кусок кода для обработки префлопа и решил, что не буду его рефактирить до дкдлайна сдачи отчета, так
как к этому моменту времени на написание самой логики приложения уходило в 3-4 раза меньше чем на рефакторинг и введение новых
дизайнерских решений и реорганизацию кода, что требовало часто переписывание 20-30% всей библиотки.

#### Часть 2. Дополнение до расширенной версии

- 3. Рефакторинг и расширение функционала
    - Начало работы над новой версией Deck (Card, Holding, Range классы)
    - Реструктуризация проекта для нового типа покера (замена префлопа на выбор диапазонов)
    - Добавление Makefile для удобного тестирования
    - Внедрение универсальной системы тестирования

- Ключевые изменения:
    - Введение системы тестирования и исправление багов.
    - Подготовка к поддержке нового типа игры (с выбором диапазонов вместо классического префлопа).

### **Глава 4. Frontend + Server**  

В этой главе будет рассмотрена разработка пользовательского интерфейса приложения, который позволит игрокам взаимодействовать с системой.  

#### Часть 1. Реализация классического покера

Программирование и математика для меня являются очень привлекательными областями из-за
того, что все концепции строятся из небольших блоков, понимание которых не доставляет проблем.
И при удилении достаточного количества времени и внимания любой человек может разобраться в громоздком концепте,
разбив его не небольшие части, которые он понимает. Когда я начал пытаться писать фронтэнд на Vue, у меня не возникало
ощущения, что я понимаю внутреннее устройство работы этого механизма и при ошибках с отображением у меня возникала тревога,
что при увеличении мастштаба проекта, у меня не получится исправлять такого рода проблемы достаточно быстро. В связи с чем было
принятно решение перейти на написание фронтэенда с минимальным колчеством зависимостей и на ванильном Javascript, в устройстве которого
разобраться гораздо проще чем в даже не самом большом фреймворке типа Vue.

В этой главе можно было бы ожидать скриншоты с тем, как выглядит финальный продукт, но я предпочту
сфокуссироваться на архитектурных деталях, так как с внешним видом можно полностью ознакомится
по ссылке на само приложение, так как оно находится в открытом доступе.

После бодрого старта в написании основ для игры в базовую версию покера, я был
оптимистично настроен по отношению к проекту и думал, что смогу быстро выкатить работающую версию
игры в покер. Всю жизнь до этого я считал, что фронтенд это простая часть разработки
приложений и это всего лишь fancy вывод на экран логики, обеспечиваемой бэкендом.
К большому удивлению, когда я начал пробовать написать простую обертку вокруг 
взаимодествия с сервером, оказалось, что я ошибался.

Я начал с программирования лобби, в котором будут отображаться доступные столы. А также
написания бэкенд логики для присоединения к столу. Я выбрал в качестве протокола взаимодействия
сервера и клиента библиотеку socket.io и JSON формат. Так как мне нужно было отображенисостояния игры
в реальном времени, но не нужна была какая-то космическая скорость, но из-за отсутствия опыта разработки
веб приложений, простота передаваемых данных играла большую роль. Дизайнерская часть продукта была разработана
по большей части при помоща базовых кнопок tailwind и его лаконичной цветовой палитры. 

После создания лобби с играми, я перешел к программированию функционала самой игры. 
Мне не хватало опыта работы с ООП в Javascript, к тому же примеры, которые я находил в интернете
были довольно низкого качества, поэтому на первых этапах мой фронтэнд выглядел как стена спагетти кода.
Реализовать игровой цикл для меня оказалось неожиданно сложной задачей, на которую у меня ушло в разы больше
времени, чем мне хотелось бы признавать. Порядок коммитов был примерно такой:

- 1. Начальная настройка и базовый функционал
    - Начало проекта (Initial commit)
    - Улучшение UI (введение Tailwind.css)
    - Реализация лобби (игроки могут создавать игры и присоединяться)

- 2. Разработка игрового цикла
    - Добавление ввода имени при входе в комнату
    - Первые шаги к игровому циклу (кнопка дилера, отображение карт на столе)
    - Переход на Node.js (только в качестве билд системы и менеджера зависимостей) и Tailwind CLI
    - Отображение карт игроков и возможность делать ставки
    - Добавление кнопок для ставок (Call, Raise), но с багами

Я старался разделить код на несколько файлов и сделать какой-то рефакторинг, но код 
все равно выглядел раздутым и тяжелым для поддержания и расширения функционала.

Структура была примерно такая:
- Огромный html файл, где фиксированна структура страницы
- Главные JS файл, делящийся на части:
    - Инициализация состояний
    - Обработка socket.io событий
    - Добавления интерактивности к компонентам через поиск по странице
Даже после вынесения ответсвенность в разные файлы, код выглядел слишком громоздко.
Вот примерная структура проекта на тот момент:

```
client
├── css
│   ├── input.css
│   └── output.css
└── js
    ├── lobby.js
    └── table
        ├── dom.js
        ├── socketio.js
        ├── table.js
        └── ui.js
```

Как я уже писал в главе про выбор технилогий, я принял решение мигрировать фронтэнд с 
Javasript на какой-то легковестный фреймворк, чтобы можно было быстрее двигаться и 
лучше структурировать код. Я выбирал между Svelte, Vue и mithril. Любому фронтэндеру
известно про первые два, но третий это довольно нишевый фреймворк самого маленького размера,
с кодом максимально близким к ванильному JS. В один момент я читал статью от создателя и 
единственного человека, на котором держиться весь lichess - платформа для игры в шахматы, 
которая на равных конкурирует с мультимилионным бизнесом chess.com. Эта статься была про историю
архитектуры lichess и этапы через которые она прошла. В ней создатель описывает свою философию 
минимализма в разработке и миграцию на mithril.js. Мне показалось близким, что
он говорит про mithril и я решил выбрать его в качестве фреймоврка для фронтенда. В частности
потому, что мне казалось, что я смогу переиспользовать уже написанный код на JS, а не писать с нуля.

Это оказалось совсем не так. Мой код на JS был написан совсем не в функциональном духе, в котором
существует mithril и оказалось, что перейти на него это далеко не тривиальная задача. При переходе 
пришлось не только переписывать абсолютно весь код кроме tailwind классов, но и с нуля изучать
механики, на которых строится рендеринг страницы в парадигме этого фреймворка, в отличии от прямого
JQuery стиля, в котором было написанно приложение на тот момент. Несмотря на это, я очень доволен, что
рещил перейти на этот фреймоворк и надеюсь остаться с ним надолго в рамках этого проекта. У меня есть 
много идей по переходу на более серьезные языки и технологии после реализации основной части проекта, но
mithril скорее всего переживет в этом плане все остальные части моего приложения.

Вот структура файлов после переход ана mithrill до рефакторинга
```
js
├── components
│   └── lobbyList.js
├── lobby.js
└── table
    ├── components
    │   ├── modal.js
    │   └── pokerTable.js
    ├── index.js
    └── socket.io.js
```

И все это с тривиальными html файлами на 20-30 строчек. Что дает очень гибкую структуру страницы
и больше контроля за организацией дерева html а также более интуитивное управление состояниями и их обновлением.
На тот момент у меня был огромный родительский класс, в котором хранятся все состояния и обрабатываются
все изменения компонентов. Он руководил компонентами modal.js для ввода имени и pokerTable.js для
всех ui компонент. 

Я решил разделить ответственность и перенаправить обновление состояний в соответствующие классы:
- Player и его отображения HeroView и VillainView
- Action и ActionsView для храниения информации о игровом действии и отображении кнопок
- modal, UsernameForm для ввода имени при входе в игру
- PokerTable, родительский класс из прошлой версии архитектуры, но сильно урезанный как клей для остальных компонент
- GameState для хранения состояния текущей раздачи и обновления состояния при обработке событий
- TableView для отображения текущего состояния раздачи

Такой рефакторинг во многом был вызван появлением dataclasses в бэкенд библиотеке для удобства
передачи информации между фронтэндом и бэкендом, о чем я уже писал в главе про библиотеку. К тому же
мне гораздо привычнее было работать с классовой структурой, хотя мне кажется что mithrill расчитывался
как более функциональный инструмент и я использую его не совсем по назначению. Но чтобы закончить эту курсовую
я не могу себе позволить осваиваться в новой парадигме програмиирования, поэтому структура проекта была выбранна 
такой.

Файловая структура после рефакторинга:
```
js
├── lobby
│   ├── components
│   │   └── lobbyList.js
│   └── lobby.js
└── table
    ├── components
    │   ├── actions.js
    │   ├── card.js
    │   ├── modal.js
    │   ├── player.js
    │   └── pokerTable.js
    ├── index.js
    ├── socket.io.js
    └── utils.js
```

A вот так выглядел мой список промежуточных целей в разработке, по которым я шел:
- Lobby 
    - Rendering of all available rooms with refresh 
    - Rewrite lobby in mithril.js 
- Room
    - Rendering of room: players, room_id 
    - Handling disconnect properly 
    - Rendering of game state 
    - Showdown rendering 
    - Rewrite room in mithril.js 
    - Restrict users from entering with existing names 
    - Render combinations on showdown 
    - New round start on client 
    - Move button
    - Convert raise sized from delta to absolute
    - Fix bugs
    - Template sizings
    - Results table
    - Nicer UI
    - Hide zero bets and pot

#### Часть 2. Дополнение до расширенной версии
####

### **Глава 5. Тестирование и результаты**  


#### Получившийся продукт со стороны пользователя

На данный момент приложение можно найти по [TODO](http://TODO). 
Функционал приложения следующий:
- Игрок при входе попадает в лобби, где есть доступные столы, а также можно создать свой
- Игрок присоединяется к столу
- При входе в комнату игрок вводит имя и задает префлоп диапазон, который он будет играть
- После того, как в комнате есть два игрока с заданными префлоп диапазонами, можно начать игру
- Игроки играют в покер, но с некоторыми особенностями:
    - Игра начинается с флопа, а не с префлопа и игрокам семплятся руки из выбранных диапазонов
    - Пот на флопе определяется при старте игры, вместе с эффективной глубиной
    - Глубина от раздачи к раздаче не меняется, а остается постоянной (пока что фиксированно 100бб)
    - Вместо глубины меняется результат, который отображается рядом с именами игроков
- Когда оба игрока находятся в олине, вместо докрутки борда, пот делится в соответсвии с эквити игроков
- При выборе диапазона можно зажать Shift и выделять вместо всего диапазона границу
- Для удобства можно использовать клавиатуру вместо кнопок для игровых решений
- Также на каждой улице есть ряд сайзингов, которые можно поставить одним движением, вместо набора с клавиатуры

#### Тестирование (TODO)

#### Сравнение с существующими решениями

В сфере тренировки в контролирумой среде со своим другом/спаринг партнером приложений я не знаю. 
Как раз поэтому я взялся за разработку этого проекта.

Мой проект выгодно отличает смещение фокуса с покера как азартной игры в сторону покера как спорта и науки.

Лучших способ освоиться в новых диапазонах в игровом формате. Я не пытался составить конуренцию игровым площадкам
в области heads-up столов, хотя нововведение с фиксированным префлоп деревом и диапазонами обрежет 
больше полвины раздач из обычного heads-up матча. Это не голословное заявление, оно опирается на статистику, которую
я собрал в своей прошлой курсовой работе, где я анализировал диапазоны из более чем трех тысяч раздач сыгранных мной в heads-up.

### Глава 6. Пути развития (TODO)

Конкретные пути развития с подробным описанием шагов.

#### Game tree nodes

- Library
- Server
- Client

#### Client optional
- Logo
- Dark gray + gold color scheme or rose-pine?
- Activate input field by default
- JS testing
- Main page with desciption and link to lobby
- Add last action on player
- Loading into existing disconnected player with same name
- Remove broke players
- Hints
- New state for winning + all_in
- Animations with regulated speed
- Table sprite + bg sprite
- Dark/Light theme
- Luckinnes
- Chat for messages
- Add abilty to change preflop range mid hand?
- Add starting pot templates
- Add starting pot input validation
- Add red border after wrong input

#### Server optional
- Make decorator for extracting info from requests
- Incapsulate data extraction in game_manager 
- Try/except assertion error in app.py
- Create tables with different stacksize/blinds/etc.
- Move game_manager tables interation to database
- Main page with desciption and link to lobby
- Add last action on player
- Loading into existing disconnected player with same name
- Flask_login
- New state for winning + all_in
- Luckinnes
- Chat for messages

### **Итоги** (TODO)

В заключении будут подведены итоги работы, описаны достигнутые результаты и намечены перспективы дальнейшего развития проекта в целом.

#### Что получилось достичь, и что не получилось (TODO)

#### Общие перспективы развития проекта (TODO)

##### Ближайшее будущее TODO: Переделать в версию в пошаговой игрой диапазонами и фиксированным деревом
1. Выбирается дерево доступных решений в рамках которого будет идти игра
2. Выбираются начальные диапазоны и текстура флопа
3. Для игроков семплятся ранауты (терн, ривер) и руки исходя из выбранной ситуации
4. В конечных вершинах, в которых залочены диапазоны считаются суммарные винрейты и скейлятся по вероятности этих вершин

##### v2.0. Расширение *boilerplate* стратегии
- Игроки фиксируют стратегии не только для префлопа, но и в первых вершинах постфлоп дерева решений диапазонами, вложеннными в диапазоны родительских вершин
- Ранауты и руки игроков семплятся не из всех возможных рук, а берутся из разных классов и скейлятся по размеру класса, чтобы избежать похожих ситуаций и еще больше усилить сходимость.

##### v3.0. Имитирующий человека ИИ
- Есть возможность отыгрывать ситуации против бота, который обучен на стратегии определенного игрока
Как обучается бот:
- Каждая рука преобразуются в вектор признаков на каждой улице
Пример:

`AKs` на префлопе:
- Premium
- Suited
- Double broadway
- ...

`AdKd` на флопе `JdTs2s`:
- Two overcards
- Gutshot
- Backdoor flush draw
- Strong draw (~50% equity against made hand)
- `A high (*absolute strength*)
- *Equity against opponent range* (30%)
- *Relative strength to our whole range* (top 20% equity against opponent range)
- ...


На полученных признаках для каждой вершины дерева обучается простая нейросеть и играет против тебя.

##### v4.0. Адаптивный ИИ
- Бот обучается на твоих действиях в реальном времени и подбирает оптимальную стратегию при помощи солвера
- Бот играет максимально эксплотирующую твой стиль игры стратегию и дообучается каждую раздачу
- Бот дообучается при помощи сдвига твой стретегии со всеми близкими по характеристикам руками в сторону принятого тобой решения
- В бот встроенна регуляризация при помощи штрафа за отклонение от оптимальной стратегии (гиперпараметр можно менять вручную)

## Терминологический словарь (TODO)

*Большая часть этого словаря сгенерированна на основе остальной части работы генеративной языковой моделью.*

1. **Heads-up Техасский Холдем**  
   - Разновидность покера, в которой играют один на один (два игрока). Отличается от других форматов покера тем, что стратегии и решения принимаются с учетом только одного оппонента.
2. **Винрейт**  
   - Показатель прибыльности игрока, выраженный в количестве выигранных денежных единиц за определенный период времени. В контексте покера — это средний выигрыш на одну руку или за определенное количество рук.
3. **Дерево решений**  
   - Графическое представление возможных решений и их последствий в покере. Каждая вершина дерева представляет собой ситуацию, в которой игрок должен принять решение (например, колл, рейз или фолд).
4. **Семплинг рук**  
   - Процесс случайного выбора рук из возможных комбинаций карт для анализа или симуляции игровых ситуаций. Используется для моделирования различных сценариев в покере.
5. **Префлоп**  
   - Этап игры в покере, который происходит до того, как на стол выложены общие карты (флоп). На этом этапе игроки принимают решения на основе своих стартовых карт.
6. **Флоп**  
   - Первые три общие карты, выложенные на стол после префлопа. Этап игры, на котором игроки начинают формировать свои комбинации.
7. **Текстура флопа**  
   - Характеристика флопа, которая описывает, насколько он "связан" или "разбросан". Например, флоп с картами одного масти или последовательными картами имеет высокую текстуру.
8. **GTO (Game Theory Optimal)**  
   - Оптимальная стратегия в покере, основанная на теории игр. GTO стратегия предполагает, что игрок делает решения, которые невозможно эксплуатировать оппонентом.
9. **Экшн (Action)**  
   - Действие, которое игрок может совершить в покере: колл, рейз, фолд или чек. В контексте префлопа — это действия, которые игроки совершают до выхода флопа.
10. **Ранаут (Runout)**  
    - Последовательность карт, которые выходят на стол после флопа (терн и ривер). Ранкаут определяет окончательную комбинацию карт.
11. **Эксплоитация (Exploitation)**  
    - Стратегия, при которой игрок адаптирует свои решения под слабости оппонента, чтобы максимизировать выигрыш. Противоположность GTO.
12. **Солвер (Solver)**  
    - Программное обеспечение, используемое для расчета оптимальных стратегий в покере. Солверы анализируют дерево решений и предлагают наилучшие действия в каждой ситуации.
13. **Регуляризация**  
    - В контексте машинного обучения и ИИ — это метод, который предотвращает переобучение модели путем добавления штрафа за сложность. В покере может использоваться для ограничения отклонений от оптимальной стратегии.
14. **Бойлерплейт (Boilerplate)**  
    - Стандартные, шаблонные ситуации в покере, которые не требуют глубокого анализа и часто решаются по базовой стратегии.
15. **Лики (Leaks)**  
    - Ошибки или слабости в стратегии игрока, которые могут быть использованы оппонентом для получения преимущества.
16. **Диапазон**  
    - Набор рук, которые игрок может иметь в определенной ситуации. Диапазон используется для анализа и принятия решений в покере.
17. **Эквити (Equity)**  
    - Вероятность выигрыша руки в текущей ситуации, выраженная в процентах. Эквити зависит от карт игрока и возможных комбинаций оппонента.
18. **Гатшот (Gutshot)**  
    - Неполный стрит-дро (четыре карты подряд с одной пропущенной картой в середине). Например, рука с картами 5-6-8-9 имеет гутшот на 7.
19. **Бэкдор флеш-дро (Backdoor Flush Draw)**  
    - Возможность собрать флеш (пять карт одной масти) на последующих улицах, если на флопе есть две карты одной масти.
20. **Двойной бродвей (Double Broadway)**  
    - Рука, состоящая из двух старших карт (например, AK, AQ, KQ), которые могут формировать сильные комбинации на флопе.
21. **Премиум руки (Premium Hands)**  
    - Сильные стартовые руки в покере, такие как AA, KK, QQ, AK. Эти руки имеют высокий потенциал для выигрыша.
22. **Относительная сила (Relative Strength)**  
    - Сила руки по сравнению с диапазоном оппонента. Например, рука может быть сильной в абсолютном выражении, но слабой относительно диапазона оппонента.
23. **Абсолютная сила (Absolute Strength)**  
    - Сила руки без учета диапазона оппонента. Например, флеш на флопе имеет высокую абсолютную силу. Так как флеш на флопе бывает очень редко и если брать все возможные покерные ситуации, эта комбинация будет стоять очень высоко.
24. **Спот (Spot)**  
    - Конкретная игровая ситуация в покере, которая требует анализа и принятия решения. Например, спот на флопе с определенной текстурой и диапазонами.
