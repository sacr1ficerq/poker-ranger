# Отчет о курсовой работе

## Оглавление

1. **Аннотация**
   - Название проекта
   - Цель проекта
   - Основные задачи
   - Планируемые результаты
   - Новизна проекта
   - Целевая аудитория
   - Ключевые слова
2. **Введение**
3. **Основная часть**
    - Глава 1. Описание предметной области и задачи
    - Глава 2. Архитектура и технологии
    - Глава 3. Backend library
    - Глава 4. Frontend + Server
    - Глава 5. Deployment
    - Глава 6. Тестирование и результаты
4. **Итоги**

   - Достигнутые результаты
   - Перспективы развития проекта

5. **Терминологический словарь**

   - Покерные термины
   - Веб-разработка

## Аннотация

**Название проекта:** Разработка веб-приложения для анализа и оптимизации игровых стратегий в Heads-up Техасском Холдеме

**Цель проекта:** Создание веб-приложения, которое позволит игрокам практиковать свои стратегии 
в игре Heads-up Техасский Холдем в контролируемой среде. 
Приложение будет использовать семплинг рук из фиксированных начальных диапазонов и
матожидание в конечных вершинах игрового дерева для
снижения дисперсии и ускорения сходимости к реальному винрейту.

**Основные задачи:**

1. Разработка графического интерфейса для игры в Техасский Холдем.
2. Создание функционала для выбора префлоп диапазона и начального пота.
3. Разработка системы для семплирования рук и расчета винрейтов.
4. Тестирование и сравнение с существующими решениями.

**Планируемые результаты:**

- Веб-приложение с интуитивно понятным интерфейсом для игровой практики фиксированных стратегий в техасском холедеме.
- Возможность точечной тренировки в изолированной игровой среде.

**Новизна проекта:**

- Новый подход к тренировке в зафиксированных игровых условиях.
- Возможность точечной тренировки определенных типов ситуаций (текстура флопа и префлоп экшн).
- Отсечение boilarplate части техасского холдема, на которую расходуется значительная часть времени и сил, при отсутсвии в них реальной возможности отколнится от базовой стратегии.

**Целевая аудитория:**

- Профессиональные игроки в покер, стремящиеся отточить свои стратегии в конкретных игровых ситуациях.
- Любители, заинтересованные в тренировке практических покерных навыков в контролируемой среде.

**Ключевые слова:** Веб-приложение, Heads-up Техасский Холдем, оптимизация стратегий, игровые алгоритмы.

## Введение

Техасский Холдем, является одной из самых популярных и сложных стратегических игр, требующей от игроков не только удачи, но и глубокого понимания общей игровой стратегии и знания паттернов поведения других игроков. В последние годы интерес к оптимизации собственных игровых стратегий значительно вырос из-за увеличения числа профессиональных игроков в онлайне и снижения винрейтов из-за общего усиления поля и повышения рейка. Однако, несмотря на наличие множества инструментов для изучения покерных стратегий, большинство из них либо слишком сложны для начинающих, либо не предоставляют достаточной гибкости для практики конкретных покерных сценариев. Кроме игры непосредственно в покер и GTO тренажеров, на текущий момент нет возможности 'пощупать' на практике определенный стратегический паттерн или отточить какой-то спот против партнера.

Целью данной работы является разработка веб-приложения, которое позволит игрокам именно эту роскошь, ради которой профессиональный игроки отыгрывают тысячи рук - пощупать стратегии в определенных спотах, получить интуитивное понимание механики покера и конкретные решения в часто встречающихся ситуациях.

Актуальность проекта обусловлена растущим интересом к покеру как к интеллектуальной игре, требующей стратегического мышления. Многие игроки, особенно начинающие, сталкиваются с трудностями при попытке проанализировать свою стратегию в определенном споте. Предлагаемое приложение позволит не только упростить этот процесс, но и сделать его более доступным для широкой аудитории, включая как профессионалов, так и любителей.

Основные задачи проекта включают разработку графического интерфейса, создание функционала для выбора дерева решений, начальных диапазонов и текстуры флопа, а также реализацию системы для семплирования рук и расчета винрейтов. Планируемые результаты включают веб-приложение с интуитивно понятным интерфейсом, которое позволит игрокам анализировать и оптимизировать свои стратегии, а также тренироваться в контролируемой среде.

Структура работы следующая: в первой главе будет дано описание предметной области и задачи, во второй главе рассмотрены архитектура и технологии, используемые в проекте, в третьей главе описана реализация алгоритмов семплирования и подсчета винрейта, в четвертой главе представлена разработка интерфейса, а в пятой главе приведены результаты тестирования и сравнение с существующими решениями. В заключении будут подведены итоги работы и намечены перспективы дальнейшего развития проекта.

Таким образом, данная работа представляет собой важный шаг в направлении создания инструментов для анализа и оптимизации покерных стратегий, которые будут полезны как для профессиональных игроков, так и для любителей, стремящихся улучшить свои навыки игры в покер. Лично для меня, как для профессионального игрока в покер, это будет резкий скачок в продуктивности изучения тонких игровых решений, а также в скорости, с которой я могу оттачивать наработанные идеи и искать лики впоследствии.

## Основная часть

### **Глава 1. Описание предметной области и задачи**

#### **Описание предметной области**

Покер это игра, где дистанция между действием и наградой за него довольно большая. Это позволяет игрокам играть без понимания настоящий винрейтов их действий и проигрывать на длинной дистанции огромные деньги. Я перешел в покер из шахмат, и был удивлен насколько некоторые игроки мало понимают механики покера и насколько большие даже для них самих деньги они при этом в него проигрывают. В шахматах гораздо проще дать оценку текущей позиции во время игры, выделить ошибки в сыгранных ходах, придти к правильным выводам и подвинуть свою игру в оптимальную сторону. Это позволяет игрокам довольно точно оценить свои шансы в игре с определенным соперником. Никакой новичек не сядет играть с гроссмейтером на большую для него сумму денег, но в покере это происходит постоянно. С появлением неполоной информации оценка матожидания определенных действий сильно размывается.

Обычный покер можно рассмотреть как стохастическую оценку надлежащей игры с полной информацией. Пример такой игры: покер раскладывается в континуальное дерево вариантов, где внутри каждой вершины игроки фиксируют свою стратегию. В результате у каждого игрока получается универсальный алгоритм игры. Столкновение алгоритмов имеет однозначно определенное матожидание, которое в точности равно матожиданию применения этих алгоритмов в обычном покере.

Конечно в такую игру не получилось бы сыграть. Но идея, что покер - ее стохастическая оценка, очень важна в контексте рассуждения про его теоритическое вопроятие. Этот стохастический процесс превносит огромную дисперсию и сильно зашумляет настоящие винрейты игроков.

Около двадцати лет появились первые солверы. Они итеративно ищут эквилибриум в подпространстве надлежащей игры с фиксированными сайзингами, в которой дерево решений кончено. Эта инъекция классического покера в конечную игру с полной информацией перевернула понимание покера и дала новый подход к изучению покерной стратегии. В современном мире большинство покерных профессионалов играют в покер не меньше, чем работают с солверами и изучают эквиоибриумы в подпространствах порожденных инъекцией классического покера в конечное дерево вариантов, так как человеческий мозг не приспособлен обучаться *end-to-end* на игре в классический покер.

Моя цель в этой курсовой работе - сделать первый шаг к созданию другой интерпретации покера как игры с полной информацией. В этой новой игре люди могут эффективно тренировать свои покерные навыки и улучшать понимание покерных механик и устройства покера с точки зрения теории игр. Попытка минимизировать шум и расстояние между действиями и реализацией их "награды".

#### **Задачи проекта**

Любой профессиональный игрок в покер в профильной дисциплине с высокой точностью знают любой диапазон, который он будет играть в любой ветке дерева решений на префлопе. Большинство профессиональных игроков отыграло десятки тысяч раздач в онлайне за 6-макс столами и все префлоп действия в раздаче против другого сильного игрока делаются автоматически.

Также большинство профессионалов имеют спаринг партнера, с которым они делятся
новыми наработками и тренируются. Тренироваться со спаринг партнером
максимально эффективно на текущий момент можно только в формате heads-up.
Однако несмотря на то, что это самый сложный вид покера и он требует
максимальной концентрации, он не помогает напрямую в игре с бОльшим количеством игроков. При этом практически во всех реальных играх учавствует больше 6 человек, и надо отдельно готовиться и изучать диапазоны, в которых стратегия постфлоп и префлоп отличается разительно от игры в heads-up. Мое приложение - самый эффективный способ отработки любых прелоп диапазонов и ситуаций в контролируемой среде со своим спаринг партнером. Допустим вы готовитесь к переходу к игре в 9-макс столах, при этом до этого оба играли только 6-макс. Оптимальные диапазоны для игры в 9-макс столах есть в открытом доступе, однако просто их запонимить будет недостаточно для эффективной реализации стратегий в этих диапазонах в боевых условиях. Мое приложение позволит вам зафиксировать играемые диапазоны с разных позиций и ситуацию например:

- BBvsBTN 3bp. 3bet pot большой блайнд против баттона.
- UTG+1vsBB SRP. Single raise pot вторая позиция против большого блайнда.
  Уникальный спот, которого нет в игре за короким столом.

В моем приложении можно зафиксировать диапазоны и проанализировать с любой
точностью в игровом формате любой спот, почувствовать как он играется в раздаче против другого сильного оппонента сколько угодно раз в любой выбранной глубине.

### **Глава 2. Архитектура и технологии**  

До этого проекта я не написал в жизни ни единой строчки на JS и не имел абсолютно никакого опыта разработки веб приложений. Было очень страшно брать большой проект в области, где у меня нет абсолютно никакой экспертизы, но я очень рад, что все таки решился на это.

Я прошел через три этапа технологий, которые я исользовал на этом проекте.

Про технологии использованные при развертывании приложения на удаленном сервере я напишу в Главе 5. Deployment.

#### Vue.js. + node_poker

 Я начал с исследования вохможных вариантов фронтэнда и остановился на `Vue.js` - относительно простой фреймворк с системой шаблонов и большим количеством синтаксического сахара. Этот вариант показался мне наиболее приемлемым с точки зрения порога входа и простоты синтаксиса. В качестве бэекенда изначальный план был использовать Next.js и переписать под свои задачи библиотеку для моделирования игры в покер `node_poker`. Однако когда я начал писать приложение, оказалось, что без знания JS и опыта пользования фронтэнд фреймворками быстро двигаться с `Vue` и отлаживать возникающие проблемы потрясающе энергозатрано, а также такой способ разработки мне очень тяжело дается, так как я не понимаю внутреннего устройства инструмента, с которым работаю. Помимо этого при пристальном взгляде внутрь библиотеки я обнаружил код такого формата:

![node-poker](data/node-poker.jpg)

Для меня это было неприемлемой опцией, так как мне нужно было быстро переписывать библиотеку под нужные мне задачи, а также чтобы вычисление выигрывающей руки работало довольно быстро, так как в дальнейшем я планировал добавить подсчет эквити диапазон против диапазона. Поэтому я полностью отказался от этой опции и начал разработку с полного нуля.

#### Radical simplicity

Чтобы лучше понять блоки, на которых строится мое приложение и индивидуальное взаимодействие компонент, я решил построить свое приложение по кирпичу на голом JS без фреймворков и излишеств.

Долгое время у меня даже не было автоматической сборки и пакетного менеджера. Я намеренно отказался в начале от `Node.js`, `Vite` и других вспомогательных инструментов. И даже LSP (language-server-protocall, **TODO**). Голый neovim и открытый в соседнем окне браузер, единственные зависимости во всем проекте - tailwind.css и socket.io через CDN/. Такой выбор был продиктован моим желанием развивать проект после окончания написания курсовой работы по его основе. Я уже несколько лет думал про то, что я хотел бы сделать в этом направлении и я не представляю реализацию проекта такого масштаба без понимания того, как устроенны внутри блоки на которых строятся основы.

Также к основе из JS я написал первую версию моей библиотеки для моделирования покерных взаимодействий между игроками на Python. При всей моей нелюбви к Python, этот язык позволяет мне двигаться максимально быстро и тратить минимум времени на рефакторинг, которого пришлось проводить довольно много в дальнейшем. Также я написал простенький сервер на `Flask` - *очень приятная библиотека для программирования энд-поинтов, выбором которой я был очень доволен.* **TODO**

После того как я закончил минимально работающую версию базового покера, я оценил структуру кода и скорость, с которой я могу дальше двигаться с vanilla JS и понял, что на большой дистанции, это не валидный вариант, и что мне все таки нужен фронэтнд фреймворк. У меня уже были минимальные знания о принципах работы JS и минимальные навыки владения синтаксисом, поэтому мне показалось, что переход на правильный фреймоворк не затормозит мое освоение основ веб программирования, а только ускорит добавление нового функционала.

#### Балланс минимализма и эргономичности

Я выбирал из трех вариантов: вернуться к `Vue`, или изучить какой-то из легковестных современных фреймворков - `Svelte` или `mithril`. `Mithril` и `Svelte` расположены довольно близко к ванильному `JS` и превносят минимальный уровень абстракции в код, что для меня показалось очень привлекательным. Я остановил свой выбор на `Mithril` после того, как узнал, что `lichess.org` в какой-то момент мигрировал на этот язык. При огромном масщтабе этого продукта, он поддерживается одним человеком, который в большей степени бэкенд разработчик. При этом мне показалось, что на этот фреймвор будет легче переписать мой JQery-style код, вместо написания фронтэнда с полного нуля. Но из-за отсутсвия понимая механик фреймворка пришлось все таки переписывать обе части - Lobby и Room с чистого листа, дублируя внешний вид существующей версии.

### **Глава 3. Backend library**

#### Часть 1. Реализация классического покера

В последующий двух главах я распишу свой путь от пустого проекта до финального результата.

Хотелось бы подчеркнуть, что этот курсовой проект для меня несет больше образовательную
ценность, чем какую-либо другую, так как несмотря на то, что проект в общем является для
меня большой целью, которую я давно хотел воплотить, у меня нет достаточных навыков,
чтобы создать продукт достаточного качества. Поэтому я буду делать акцент в этом отчете именно на
своей образовательной траектории и как я шел к финальному продукту, а не на архитектурных деталях получившегося
приложения.

Изначально, как я уже отметил во втрой главе, я планировал использовать Vue и уже готовую библиотеку
для моделирования игры в покер. Однако увидев содержание библиотеки, я понял, что 
не смогу дописывать в нее нужный мне функционал, а также мне комфортнее будет двигаться на Python самому.
Поэтому я решил начать с чистого листа и находу разобраться с архитектурой и механикой
работы движка для моделирования покера.

Как я понял, разные программисты любят начинать с разных концов проекта - кто-то с написания основ 
бэкенд библиотки, кто-то с набрасывания фундамента фронтэнда, под который потом пишется бэекенд.
Мне гораздо проще было начать писать бэкенд с нуля, так как я очень отдаленно представлял себе
как будет выглядет фронтэнд и предполагал, что создание бекэнд архитектуры будет неплохим стартом, который 
даст мне фундамент, на котором я смогу выстраивать логику приложения.

С начала проекта я решил фиксировать важные продвижения через систему контроля версий.
Как раз чтобы по нимпроще было писать отчет. Надеюсь, это поможет мне не упустить
важных деталей разработки и позволит лучше отобразить мою траекторию.

Все мои коммиты и стадии разработки можно найти в моем репозитории на (github.com.)[TODO]

Первые шаги в сторону реализации бозового покера были сделаны довольно в быстром темпе.
Я начал с того, что создал три класса - Table, Player, Round. В них я хотел инкапсулиовать
логику соответствующий объектов.

- Table отвечает за то, какие игроки сидят за столом, взаимодействие с ними, а также их
посадка/высадка. Также поддерживается проеужточная информация формата: у кого сейчас кнопка
диллера. Через этого класс идет взаимодействие фронтенда с бекендом, хотя на тот момент не до конца было понятно, как именно это будет реализованно.

```python
class Table:
    def __init__(self, sb, bb):
        self.bb = bb
        self.sb = sb
        self.players = []
        self.button = 0  # button index

        self.current_round = None
```

- Round отвечает за хранение динамической информации типа размер пота, чье сейчас слово, внутриигровые действия,
переход между улицами, постановка блайндов.

Примерно так выгляделели поля внутри класса:

```python
class Round:
    def __init__(self, players, table):
        # players in game (including all_in) sorted by left to act
        first = table.button + 1

        self.players = players[first:] + players[:first]
        assert len(players) >= 2, 'not enough players'
        self.table = table

        self.sb = table.sb
        self.bb = table.bb

        self.street = 'preflop'
        self.deck = Deck()
        self.pot = 0
        self.max_bet = 0
        self.board = []
```

- Player отвечает за класс игрока. Простым решением, о котором я жалею, было инкапсулировать игровые действия
внутри него, что приводит к цикличной ссылке на родительский класс и проверку состояний через обращение к этому классу.

Вот так выглядели все функции игровых действий:

``` python
def call(self, max_bet):
    assert max_bet != 0, 'cant call while bet == 0'
    assert not self.folded, 'player already folded'
    assert self.is_acting
    amount = max_bet - self.chips_bet
    if amount >= self.stack:
        self.all_in = True
        amount = self.stack

    self.stack -= amount
    self.chips_bet += amount

    print(f'player {self.name} calls {amount}')
    self.acted = True
    self.table.current_round.action(amount)
```

Общее назначение класса было хранить информацию про игрока, а именно: его стек, сколько он поставил в
этом раунде, какие у него в руке карты, а также флаги: в олине игрок, сыграл ли он уже в этот круг и его ли сейчас очередь играть.
В основном все эти решения выступали как костыли для сиюминутного решения проблем, и потом часть из них, например состояние, было
переделано по-другому, но на тот момент это казалось интутивным решением.

```python
class Player:
    def __init__(self, name, stack, table):
        self.name = name
        self.stack = stack
        self.table = table

        self.sit_out = False

        self.folded = False
        self.all_in = False
        self.acted = False
        self.is_acting = False

        self.chips_bet = 0

        self.cards = []
```

Также я добавил класс Deck, который я планировал сильно расширить при добавлении функционала,
связанного с семплингом рук из диапазона и другие взаимодействия с вероятностным подходом
к семплигну карт. На тот момент его функцией было просто хранение живых карт, а также перемешивание
при создании нового экземпляра.

``` python
class Deck:
    def __init__(self):
        self.deck = []
        self.fill()
        self.shuffle()
```

Это уже могло работать и можно было отыгрывать префлоп, но не было поддержки шоудауна, а также проблемы
с олинами и некоторые баги связанные с неправильным определение позиции игрока на определенной улице.
Мне понравилось мое решение в начале раунда фиксировать порядок игроков за столом на постфлопе, а не
вычислять его каждый раз заново. В тот момент я слабо понимал в какую сторону будет расти приложение, поэтому
я писал покер для общего случая с любым количеством игроков, что я изменил в процессе разработке далее.

Большой проблемой было тестирование. В Python я не работал с тестами, а писал до этого только большие классы для
тестирования на C++ с помощью Google Test. В этом проекте я тестировал все при помощи файла example.py, что
было не очень удобно и на это уходило много времени. В последующий версиях мне удалось это исправить.

После написания нетривиальной функции для определения победителя на шоудауне, я решил, что стоит приступить к написанию базового фронтэнда. Эту функцию (оценки выигрывающей руки) я написал при помощи генеративной нейросети, так как обработать все edge кейсы было довольно затруднительно, особенно в отсутсвии хорошего пайплайна с тестированием. Мне все равно казалось это более правильным решением, чем использовать сторонние покерные библиотеки, так как я точно понимал, что происходит внутри и к тому же избегал полностью завасимостей от других пакетов.

После написания базового фронтенда обнаружилось множество багов. Чтобы тестировать работоспособность библиотеки необходимо было разработать систему для тестирования различных частей программы. Для этого я выбрал pytest - довольно популярное решение для написания юнит тестов. В первых версиях тестирования код был неорганизован и по сути
тестировал только класс Round, а остальные классы цеплял только через зависимость поведения Round от них.
Для улучшения процесса разработки и тестирования, а также для лучшей коммуникации между фронтэндом и бэкендом я провел
небольшой рефакторинг, который был вызван идеей переделать архитектуру хранения и обновления состояний во фронтэнде. Теперь класс Player не хранил
все состояния через флаги, а хранил поле типа PlayerState, которое однозначно определяло в каком состоянии находится игрок. Это позволяло более изящно решить ряд проблем на стороне фронтэнда и избегало багов с одновременными состояниями.

```python
class PlayerState(Enum):
    BASE = ''
    FOLDED = 'folded'
    ALLIN = 'all-in'
    ACTING = 'acting'
    WINNING = 'winning'
    LOOSING = 'loosing'
    SITOUT = 'sit-out'
```

Вместе с ним был добавлен другой enum класс Action, хранящий игровые действия игрока. Во все классы для коммуникации с фронтэндом был добавлен метод state(), который сам сериализовывал нужные для отображения поля и отдавал для последующей сериализации в JSON словарь из примитивных типов. Также для скрытия карт игрока от других, был добавлен метод private_state, который вызывался сервером для персонального обновления
состояний. В процессе рефакторинга, я переписал ключевые методы полностью под heads-up версию покера, так как решил, что мое приложение в обозримом будущем будет поддерживать только эту версию.

Во время написания тестов и рефакторинга фронтенда, я заметил очень неприятную особенность JS. Возможно это продиктованно моим отсутствием опыта с языком, но у меня часто возникали проблемы с десериализацией состояний на стороне клиента, а также с десериализацией информации про запрос со стороны сервера. Я знаю, что эту проблему во многом решает миграция на TypeScript, но мне нравилось оставаться в nobuild парадигме, к тому же не хотелось рассеивать внимание на множество проблем, которые невозможно было предвидеть от переноса кода на TypeScript и введения дополнительных шагов. Это наталкнуло меня на использование очень приятного инструмента на строне бэкенда - Python dataclasses.
В dataclasses есть метод todict, который позволяет очень удобно конвертировать состояния в промежуточный формат словаря из примитивных типов, который легко сериализуется
в JSON. Я разработал новую систему состояний для каждого объекта, про который требовалась информация на стороне клиента:

- TableData
- PlayerData
- RoundData

Теперь у меня был отдельный красивый файл states.py, в который я мог обращаться при уточнении, какого типа то или иное поле в отправленном
состоянии, а также LSP подсказывал мне, когда я конвертировал в неправильный формат при работе с библиотекой или при добавлении новых
эндпоинтов на сервере. С этим упрощением работы процесс тестирования тоже сильно упростился. также я переоткрыл для себя Python в новом виде. Я пробежался по всему коду и проставил тайпинги в каждой функции, и получилось поймать несколько багов, а также ускорить написание нового кода.
Стыдно признаться, что я не использовал эту возможность до этого. В больших функциях с неясным return value я проставлял тайпинги, но
точно в том масштабе, в который я превратил новую версию моей codebase.

После этих улучшений я легко дописал функционал для обработки олинов, а также тестирования многих других граничных случаев. К примеру
самой большой проблемой оказался стык суперкоротких стеков и автоматической постановки блайндов. Для устранения багов в этой области я
написал небольшой, но очень некрасивый кусок кода для обработки префлопа и решил, что не буду его рефактирить до дедлайна сдачи отчета, так
как к этому моменту времени на написание самой логики приложения уходило в 3-4 раза меньше чем на рефакторинг и введение новых
дизайнерских решений и реорганизацию кода, что требовало часто переписывание 20-30% всей библиотки.

#### Часть 2. Дополнение до расширенной версии

После того, как я закончил кое-как работающую версию базового покера, я приступил к нововведениям, приближающим меня к той версии покера, к которой я стремился изначально.
Для реализации новой версии префлопа я создал новые классы:

- Card, класс, позволяющий удобно работать с картами и получать представления из индексов, в которых идет работа внутри диапазона.
- Holding, класс, позволяющий переводить на понятный язык ячейки из Range и инкапсулировать информацию о конкретной руке каждого игрока.
- Range, класс ради которого создавались остальные два. Созданный для хранения и передачи во фронтэенд представления диапазона игроков.

После чего, я переделал функцию старта стола и раздачи в начале каждого раунда под семлирование из конкретных диапазонов. Здесь появилась моя первая зависимость от numpy. В этом конкретном случае можно было бы отказаться от нее и написать функционал самому, но я решил, что nunpy может помочь мне с программированием нового функционала, а также зависимость от numpy не казалась чем-то ненадежным, так сегодня это практически как часть стандартной библиотеки Python.

С введением нового функционала появилось много проблем и я решил серьезно взяться за написание достаточно хорошей системы тестирования библиотеки и провел масштабный рефактиринг моих тестов. С помощью pytest.fixtures получилось добиться приятного сетапа для написания тестирующий системы. Большим шагом, который далеко продвинул меня было написание универсальной функции для тестирования покерных линий типа 'xb3.0cxxb6.0f' - линия из трех улиц, в которой игрок в позиции
поставил на флопе 3.0, чекнул терн и выкинул на ставку в 6.0 на ривере. Таким образом я мог быстро написать тесты под большое количество ситуаций и это помогло мне быстро прокидывать с фронтэенда баги и тесировать реакцию движка на определенные линии. Также для удобства управления я добавил Makefile, который позволил мне избавится от ввода бесконечных скриптов в bash для тестирования конкретного функционала.

### **Глава 4. Frontend + Server**  

#### Часть 1. Реализация классического покера

Программирование и математика для меня являются очень привлекательными областями из-за
того, что все концепции строятся из небольших блоков, понимание которых не доставляет проблем.
И при удилении достаточного количества времени и внимания любой человек может разобраться в громоздком концепте,
разбив его не небольшие части, которые он понимает. Когда я начал пытаться писать фронтэнд на Vue, у меня не возникало
ощущения, что я понимаю внутреннее устройство работы этого механизма и при ошибках с отображением у меня возникала тревога,
что при увеличении мастштаба проекта, у меня не получится исправлять такого рода проблемы достаточно быстро. В связи с чем было
принятно решение перейти на написание фронтэенда с минимальным колчеством зависимостей и на ванильном Javascript, в устройстве которого
разобраться гораздо проще чем в даже не самом большом фреймворке типа Vue.

В этой главе можно было бы ожидать скриншоты с тем, как выглядит финальный продукт, но я предпочту
сфокуссироваться на архитектурных деталях, так как с внешним видом можно полностью ознакомится
по ссылке на само приложение, так как оно находится в открытом доступе.

После бодрого старта в написании основ для игры в базовую версию покера, я был
оптимистично настроен по отношению к проекту и думал, что смогу быстро выкатить работающую версию
игры в покер. Всю жизнь до этого я считал, что фронтенд это простая часть разработки
приложений и это всего лишь fancy вывод на экран логики, обеспечиваемой бэкендом.
К большому удивлению, когда я начал пробовать написать простую обертку вокруг 
взаимодествия с сервером, оказалось, что я ошибался.

Я начал с программирования лобби, в котором будут отображаться доступные столы. А также
написания бэкенд логики для присоединения к столу. Я выбрал в качестве протокола взаимодействия
сервера и клиента библиотеку socket.io и JSON формат. Так как мне нужно было отображенисостояния игры
в реальном времени, но не нужна была какая-то космическая скорость, но из-за отсутствия опыта разработки
веб приложений, простота передаваемых данных играла большую роль. Дизайнерская часть продукта была разработана
по большей части при помоща базовых кнопок tailwind и его лаконичной цветовой палитры. 

После создания лобби с играми, я перешел к программированию функционала самой игры. 
Мне не хватало опыта работы с ООП в Javascript, к тому же примеры, которые я находил в интернете
были довольно низкого качества, поэтому на первых этапах мой фронтэнд выглядел как стена спагетти кода.
Реализовать игровой цикл для меня оказалось неожиданно сложной задачей, на которую у меня ушло в разы больше
времени, чем мне хотелось бы признавать. Порядок коммитов был примерно такой:

- 1. Начальная настройка и базовый функционал
    - Начало проекта (Initial commit)
    - Улучшение UI (введение Tailwind.css)
    - Реализация лобби (игроки могут создавать игры и присоединяться)

- 2. Разработка игрового цикла
    - Добавление ввода имени при входе в комнату
    - Первые шаги к игровому циклу (кнопка дилера, отображение карт на столе)
    - Переход на Node.js (только в качестве билд системы и менеджера зависимостей) и Tailwind CLI
    - Отображение карт игроков и возможность делать ставки
    - Добавление кнопок для ставок (Call, Raise), но с багами

Я старался разделить код на несколько файлов и сделать какой-то рефакторинг, но код 
все равно выглядел раздутым и тяжелым для поддержания и расширения функционала.

Структура была примерно такая:

- Огромный html файл, где фиксированна структура страницы
- Главные JS файл, делящийся на части:
    - Инициализация состояний
    - Обработка socket.io событий
    - Добавления интерактивности к компонентам через поиск по странице

Даже после вынесения ответсвенность в разные файлы, код выглядел слишком громоздко.
Вот примерная структура проекта на тот момент:

```
client
├── css
│   ├── input.css
│   └── output.css
└── js
    ├── lobby.js
    └── table
        ├── dom.js
        ├── socketio.js
        ├── table.js
        └── ui.js
```

Как я уже писал в главе про выбор технилогий, я принял решение мигрировать фронтэнд с 
Javasript на какой-то легковестный фреймворк, чтобы можно было быстрее двигаться и 
лучше структурировать код. Я выбирал между Svelte, Vue и mithril. Любому фронтэндеру
известно про первые два, но третий это довольно нишевый фреймворк самого маленького размера,
с кодом максимально близким к ванильному JS. В один момент я читал статью от создателя и 
единственного человека, на котором держиться весь lichess - платформа для игры в шахматы, 
которая на равных конкурирует с мультимилионным бизнесом chess.com. Эта статься была про историю
архитектуры lichess и этапы через которые она прошла. В ней создатель описывает свою философию 
минимализма в разработке и миграцию на mithril.js. Мне показалось близким, что
он говорит про mithril и я решил выбрать его в качестве фреймоврка для фронтенда. В частности
потому, что мне казалось, что я смогу переиспользовать уже написанный код на JS, а не писать с нуля.

Это оказалось совсем не так. Мой код на JS был написан совсем не в функциональном духе, в котором
существует mithril и оказалось, что перейти на него это далеко не тривиальная задача. При переходе пришлось не только переписывать абсолютно весь код кроме tailwind классов, но и с нуля изучать механики, на которых строится рендеринг страницы в парадигме этого фреймворка, в отличии от прямого JQuery стиля, в котором было написанно приложение на тот момент. Несмотря на это, я очень доволен, что реiил перейти на этот фреймоворк и надеюсь остаться с ним надолго в рамках этого проекта. У меня есть много идей по переходу на более серьезные языки и технологии после реализации основной части проекта, но mithrill скорее всего переживет в этом плане все остальные части моего приложения.

Вот структура файлов после переход ана mithrill до рефакторинга

```
js
├── components
│   └── lobbyList.js
├── lobby.js
└── table
    ├── components
    │   ├── modal.js
    │   └── pokerTable.js
    ├── index.js
    └── socket.io.js
```

И все это с тривиальными html файлами на 20-30 строчек. Что дает очень гибкую структуру страницы
и больше контроля за организацией дерева html а также более интуитивное управление состояниями и их обновлением.
На тот момент у меня был огромный родительский класс, в котором хранятся все состояния и обрабатываются
все изменения компонентов. Он руководил компонентами modal.js для ввода имени и pokerTable.js для
всех ui компонент.

Я решил разделить ответственность и перенаправить обновление состояний в соответствующие классы:

- `Player` и его отображения `HeroView` и `VillainView`
- `Action` и ActionsView для храниения информации о игровом действии и отображении кнопок
- `modal`, `UsernameForm` для ввода имени при входе в игру
- `PokerTable`, родительский класс из прошлой версии архитектуры, но сильно урезанный как клей для остальных компонент
- `GameState` для хранения состояния текущей раздачи и обновления состояния при обработке событий
- `TableView` для отображения текущего состояния раздачи

Такой рефакторинг во многом был вызван появлением `dataclasses` в бэкенд библиотеке для удобства
передачи информации между фронтэндом и бэкендом, о чем я уже писал в главе про библиотеку. К тому же мне гораздо привычнее было работать с классовой структурой, хотя мне кажется что `mithrill` расчитывался
как более функциональный инструмент, и я использую его не совсем по назначению. Но чтобы закончить эту курсовую я не могу себе позволить осваиваться в новой парадигме программирования, поэтому структура проекта была выбранна такой.

Файловая структура после рефакторинга:
```
js
├── lobby
│   ├── components
│   │   └── lobbyList.js
│   └── lobby.js
└── table
    ├── components
    │   ├── actions.js
    │   ├── card.js
    │   ├── modal.js
    │   ├── player.js
    │   └── pokerTable.js
    ├── index.js
    ├── socket.io.js
    └── utils.js
```

A вот так выглядел мой список промежуточных целей в разработке, по которым я шел:

- Lobby
  - Rendering of all available rooms with refresh
  - Rewrite lobby in mithril.js
- Room
  - Rendering of room: players, room_id
  - Handling disconnect properly
  - Rendering of game state
  - Showdown rendering
  - Rewrite room in mithril.js
  - Restrict users from entering with existing names
  - Render combinations on showdown
  - New round start on client
  - Move button
  - Convert raise sized from delta to absolute
  - Fix bugs
  - Template sizings
  - Results table
  - Nicer UI
  - Hide zero bets and pot

#### Часть 2. Дополнение до расширенной версии

После введения новой структуры игры в бэкенд библиотеке, я уже хорошо представлял, как должна измениться архитектура фронтэнда, а также структура моего фронтэнда была заранее хорошо адаптированна к подобным изменениям, так как при последнем рефактиринге я учитывал направление разработки. Также промежуточный класс GameManager, который был дописан к flask и socket.io хэндлерам позволял мне достаточно быстро адаптировать изменения в библиотеке к существующей структуре проекта во фронтэнде. Я дописал парный класс Range и RangeView в файл к modal. Основные проблемы возникли с оформлением диапазона и UX. Так как css и html для меня тоже абсолютно новые области, а выбор диапазона это самая сложна по структуре составляющая моей страницы. В целом я остался доволен полученным результатом. На мой взгляд UX получается довольно интуитивным и позволяет достаточно быстро отыгрывать раздачи, что очень важно в длительных матчах, в которых основная цель наиграть побольше раздач для последующего анализа.  

### **Глава 5. Deployment**

После окончания доработки основного функционала на стороне библиотеки, сервера и фронтэенда, я решил попубликовать свой проект в открытый доступ. Так как большинство платформ для хостинга
на данный момент не доступны из России, я выбирал из Yandex Cloud, Selectel Cloud и Timeweb Cloud. После небольшого исследования я остановился на Timeweb Cloud из-за простоты использования и приемлемой цены. После чего я арендовал VPS с такими характеристиками:

- **CPU**: 1 x 3.3 ГГц
- **RAM**: 1 ГБ
- **NVMe**: 15 ГБ
- **Connection**: 1 Гбит/с

А также приобрел домен [poker-ranger.ru](http:/poker-ranger.ru).

Так как я не являюсь экспертом в этой области, по инструкциям в интернете у меня получилось развернуть свое приложение на сервере без особых трудностей. В качестве WSGI-сервера я взял Gunicorn. И в качестве прокси сервера nginx. Сетап из Makefile и доступность для клонирования бэкенд библиотеки и основного репозитория приложения дали мне возможность довольно быстро развернуть его на виртуальной машине. Честно говоря, я без особого понимания сконфигурировал nginx и Ginicorn, но я надеюсь разобраться в этой теме глубже после того, как закончу с основным функционалом моего приложения.

### **Глава 6. Тестирование и результаты**  

#### Получившийся продукт со стороны пользователя

На данный момент приложение можно найти по [ссылке](http://poker-ranger.ru).
Функционал приложения следующий:

- Игрок при входе попадает в лобби, где есть доступные столы, а также можно создать свой
- Игрок присоединяется к столу
- При входе в комнату игрок вводит имя и задает префлоп диапазон, который он будет играть
- После того, как в комнате есть два игрока с заданными префлоп диапазонами, можно начать игру
- Игроки играют в покер, но с некоторыми особенностями:
  - Игра начинается с флопа, а не с префлопа и игрокам семплятся руки из выбранных диапазонов
  - Пот на флопе определяется при старте игры, вместе с эффективной глубиной
  - Глубина от раздачи к раздаче не меняется, а остается постоянной (пока что фиксированно 100бб)
  - Вместо глубины меняется результат, который отображается рядом с именами игроков
- Когда оба игрока находятся в олине, вместо докрутки борда, пот делится в соответсвии с эквити игроков
- При выборе диапазона можно зажать Shift и выделять вместо всего диапазона границу
- Для удобства можно использовать клавиатуру вместо кнопок для игровых решений
- Также на каждой улице есть ряд сайзингов, которые можно поставить одним движением, вместо набора с клавиатуры

#### Сравнение с существующими решениями

В сфере тренировки в контролирумой среде со своим другом/спаринг партнером приложений я не знаю.
Как раз поэтому я взялся за разработку этого проекта.

Мой проект выгодно отличает смещение фокуса с покера как азартной игры в сторону покера как спорта и науки. Я не надеюсь изменить им представление каких-то людей о покере, так как мое прилоежие направленно на ту чать аудитории покера, которая и так подходит к нему со спортивной стороны.

Я не пытался составить конуренцию игровым площадкам в области heads-up столов, хотя нововведение с фиксированным префлоп деревом и диапазонами обрежет больше полвины раздач из обычного heads-up матча. Так что я планирую добавить этот формат после завершение основной части проекта.
Определенно UI и UX моего приложения сильно отстает от стандартов для карточных игр, на текущий момент у меня нет ни единой анимации, так как моей целью было достичь работающей версии в кратчайшие сроки до дедлайна по курсовому проекту, а это было бы невозможно, если бы я расходовал время на приятные дополнения в UI, при полном отсутствии опыта.

Зато мое приложение не требует регистрации и можно в три клика оказаться за столом и начать тренировать определенный спот, если есть спаринг партнер. На данный момент требуется координация между игроками до начала матча по тому, какую конкретно ситуацию они будут тренировать. Однако в скором времени я надеюсь добавить шаблоны для отыгрывания определенных ситуаций, чтобы можно было сыграть со случайными человеком из лобби и возможно даже обрести себе спаринг партнера.

#### Coming soon

У меня есть множество планов по улучшению текущей версии приложения вот примерный список улучшений, которые будут добавленны в ближайшем будущем:

**На стороне клиента**:

- Логотоп продукта. У меня уже есть некоторые зарисовки.
- Переделать цветовую палитру в темно-серый с золотым или rose-pine, чтобы подходило к цвету стола
- Активировать поле ввода ставки без нажатия курсором
- Добавить тестирование во фронтэнд, так как сейчас система тестирования есть только для бэкенд библиотеки, в во фронтэнде все тестируется руками
- Добавить страницу с описанием проекта, на которую люди будут попадать изначально
- Добавить последнее действие рядом с именем игрока, как это сделано на большинстве площадок
- При дисконнете, можно будет загрузится в свой стейт, без потери данных
- Висящие подсказки с описанием горячих клавиш и функционала
- Анимации
- Светлая/Темная темы
- Фактор удачи, который считается походу матча
- Чат, в котором игроки могут переписываться
- Возможность изменять префлоп диапазон во время раздачи
- Добавить новое состояние после выигрыша при олине
- Добавить красную подсветку при неправильных действиях

**На стороне сервера**:

- Декораторы для валидации запросов
- Добавить взаимодействие с базой данных, куда сохранять раздачи. Также можно будет получить список раздач сыгранных в матче в формате csv для последующего анализа.
- Релизация опционального логина с помощью Flask_login
- Реализовать подсчет удачливости игроков

### **Итоги**

#### Достигнутые результаты

Для меня было большим удовольствием создать полноценный продукт, который могут использовать другие люди и я очень доволен, что у меня сошелся пазл из различных блоков программирования, про которые я отдаленно слышал, но никогда не использовал на практике. До этого самое близкое что я делал к реализации веб приложения - написание netcat сервера на С.

Я очень рад, что при полном отсутствии опыта веб разработки, получилось собрать работающую версию приложения. Пусть даже сейчас это больше похоже на зарисовку поставленной цели, чем на полноценный продукт, которым будет пользоваться множество людей. Цели при разработке этого проекта были поставленны на полное понимание внутренностей и механик работы приложения, я спецаильно старался двигаться без зависимостей от сторонних пакетов и заимстования какого-либо кода. Также я отказался в первой части проекта от использования LSP при написании кода на JS. Достижение этих целей позволит мне быстро развивать этот проект дальше и растить codebase вокруг написанного мной лично кода.

#### Общие перспективы развития проекта

Полученная инфаструктура дает мне массу возможностей для внедрения самого разного рода алгоритмов и расширения функционала. Я планирую доделать режим, который я не успел *смерджить* в основную ветку, вот его описание:

Игроки на постфлопе продолжают вести весь диапазон вместо конкретной руки. Каждое игровое действие игрока делается в два этапа:

1. Игрок выбирает распределение действий всего диапазона
2. Игрок распределяет свой диапазон по действиям так, чтобы распределение диапазона соответствовало зафиксированному распределению из первого этапа.

Игра также остается пошаговой, но вместо одной руки, в следующий этап прокидывается весь диапазон. Это реализованно следующим образом:

После того, как игрок А выбрал распределение по действиям своего диапазона, сервер получает распределение и из него семплится конкретное действие и сообщается игроку Б. Игрок А, не зная, какое действие было выбранно, размечает свой диапазон в соответствии с выбранным распределением. После получения действия, случайно выбранного из распределения, игрок Б также выбирает распределение стратегий, из которого сервер семплит конкретное действие, которое будет отправленно игроку А после того, как он разметит полностью свой диапазон.

Когда семплится конечная вершина в какой-то из стадий игры, считается матожидание диапазона против другого диапазона и добавляется к результатам, и игроки переходят к следующей раздаче.

Этот режим позволят максимально глубоко понять, как внутри работает математика покера и как между собой взаимодействуют диапазоны в разной эффективной глубине и на различных текстурах. Внутри этого режима также будет поддержка старта игры в какой-то конкретной вершине после префлопа в конкретных стартовых диапазонах и выбранном стартовом поте, как в существующией версии моего проекта.

Этот режим требует фиксации конкретного дерева решений, которое выбирается при создании игры.

## Полный терминологический словарь

*Большая часть этого словаря сгенерированна на основе остальной части работы генеративной языковой моделью.*

### Покерные термины

1. **Heads-up Техасский Холдем**  
   - Формат покера один на один (2 игрока). Стратегии строятся с учетом действий только одного оппонента.

2. **Винрейт**  
   - Показатель прибыльности игрока, измеряемый как средний выигрыш на дистанции. В проекте используется для оценки эффективности стратегий.

3. **Дерево решений**  
   - Модель возможных игровых действий (колл, рейз, фолд) и их последствий. Ключевой элемент для анализа стратегий в покере.

4. **Семплинг рук**  
   - Случайный выбор карт из заданных диапазонов для моделирования игровых ситуаций. Используется для снижения дисперсии при расчете матожидания.

5. **Префлоп**  
   - Начальный этап раздачи, где игроки принимают решения до выхода общих карт (флопа). В проекте диапазоны фиксируются именно на этом этапе.

6. **Флоп**  
   - Первые три общие карты. В приложении игра начинается с флопа, а префлоп-действия зафиксированы.

7. **Текстура флопа**  
   - Характеристика флопа, определяющая его "связанность" (одинаковые масти, последовательные карты). Позволяет выделять типовые игровые ситуации для тренировки.

8. **GTO (Game Theory Optimal)**  
   - Стратегия, устойчивая к эксплуатации. В проекте упоминается как основа для анализа, но акцент сделан на тренировке конкретных спотов.

9. **Экшн (Action)**  
   - Действие игрока (например, 3bet на префлопе). В приложении можно фиксировать диапазоны для определенных экшенов.

10. **Ранаут (Runout)**  
    - Карты на терне и ривере. В проекте ранауты семплятся для ускорения сходимости результатов.

11. **Бойлерплейт (Boilerplate)**  
    - Стандартные игровые ситуации, где отклонение от базовой стратегии минимально. В проекте такие ситуации исключаются для фокусировки на ключевых спотах.

12. **Лики (Leaks)**  
    - Слабости в стратегии игрока. Одна из целей приложения — выявление и устранение ликов через анализ конкретных ситуаций.

13. **Диапазон**  
    - Набор рук, которые игрок может иметь в определенной ситуации. В приложении диапазоны фиксируются для изолированной тренировки.

14. **Эквити (Equity)**  
    - Вероятность выигрыша руки против диапазона оппонента. Используется для расчета результатов в конечных вершинах дерева решений.

15. **Спот (Spot)**  
    - Конкретная игровая ситуация (например, "BBvsBTN 3bet pot"). Основной объект анализа в приложении.

16. **Солвер (Solver)**  
    - Программа для расчета оптимальных стратегий. Упомянут как инструмент, с которым работают профессионалы.

### Веб разработка

1. **Vue.js**  
   - JavaScript-фреймворк, изначально выбранный для фронтенда. Отказан из-за сложности освоения.

2. **Mithril.js**  
   - Легковесный фреймворк, на который мигрировал фронтенд. Выбран из-за близости к ванильному JS и минимализма.

3. **Flask**  
   - Микрофреймворк Python для бэкенда. Использовался для создания API и обработки игровой логики.

4. **Socket.io**  
   - Библиотека для реализации реального времени. Обеспечивала синхронизацию состояний между игроками.

5. **Tailwind CSS**  
   - CSS-фреймворк для стилизации интерфейса. Использовался без сборки через CDN.

6. **Vanilla JS**  
   - Чистый JavaScript без фреймворков. Начальная версия фронтенда была написана на нем.

7. **Node.js**  
   - Среда выполнения JS. Подключался позже для управления зависимостями.

8. **Gunicorn**  
   - WSGI-сервер для развертывания Python-приложения на продакшене.

9. **Nginx**  
   - Веб-сервер, используемый как обратный прокси для маршрутизации запросов.

10. **JSON**  
    - Формат обмена данными между клиентом и сервером. Все состояния игры сериализовывались в JSON.

11. **LSP (Language Server Protocol)**  
    - Протокол для поддержки автодополнения в редакторе. Упомянут в контексте отказа от его использования.

12. **Pytest**  
    - Фреймворк для тестирования бэкенд-логики. Внедрен после обнаружения багов в ручном тестировании.

13. **VPS (Virtual Private Server)**  
    - Сервер в Timeweb Cloud, на котором было развернуто приложение.

14. **WSGI (Web Server Gateway Interface)**  
    - Стандарт взаимодействия между сервером и Python-приложением. Использовался через Gunicorn.

15. **UI/UX**  
    - Пользовательский интерфейс и опыт. В проекте упор сделан на функциональность, а не на визуальную составляющую.

16. **Makefile**  
    - Файл для автоматизации задач (сборка, тесты, деплой).

17. **GitHub**  
    - Платформа для хостинга кода. Все этапы разработки фиксировались в репозитории.
